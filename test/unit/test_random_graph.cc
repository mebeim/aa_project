/**
 * Unit tests for random-graph generation utilities that are used for actual
 * testing.
 */

#include <vector>
#include <tuple>
#include <unordered_set>
#include <boost/graph/connected_components.hpp>
#include <boost/graph/adjacency_list.hpp>
#include <boost/range/algorithm.hpp>
#include <boost/test/unit_test.hpp>

#include "utils.h"
#include "random_graph.h"

BOOST_AUTO_TEST_SUITE(RandomGraphGenerators)

#define REPEAT(n) for (unsigned i__ = 0; i__ < (n); i__++)

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS> Graph;
typedef VertexDesc<Graph> Vertex;
typedef VertexSizeT<Graph> VertexSz;

/**
 * Ensure that graphs generated by gen_random_connected_graph() are simple i.e.
 * they don't have multiple parallel edges between any pair of vertices.
 */
BOOST_AUTO_TEST_CASE(random_connected_graph_is_simple) {
	REPEAT(10) {
		Graph g = gen_random_connected_graph<Graph>(100, 1);

		for (auto v : iter_vertices(g)) {
			auto neighbors = std::make_from_tuple<std::unordered_set<Vertex>>(boost::adjacent_vertices(v, g));
			BOOST_CHECK_EQUAL(neighbors.size(), boost::degree(v, g));
		}
	}
}

/**
 * Ensure that graphs generated by gen_random_connected_graph() are actually
 * connected.
 */
BOOST_AUTO_TEST_CASE(random_connected_graph_is_connected) {
	REPEAT(100) {
		Graph g = gen_random_connected_graph<Graph>(100, 0);

		std::unordered_map<Vertex, VertexSz> component(boost::num_vertices(g));
		auto map = boost::make_assoc_property_map(component);
		auto n_components = boost::connected_components(g, map);

		BOOST_CHECK_EQUAL(n_components, 1);
	}
}

/**
 * Ensure that graphs generated by gen_random_chordal_graph() are simple i.e.
 * they don't have multiple parallel edges between any pair of vertices.
 */
BOOST_AUTO_TEST_CASE(random_chordal_graph_is_simple) {
	REPEAT(10) {
		Graph g = gen_random_chordal_graph<Graph>(100, 500);

		for (auto v : iter_vertices(g)) {
			auto neighbors = std::make_from_tuple<std::unordered_set<Vertex>>(boost::adjacent_vertices(v, g));
			BOOST_CHECK_EQUAL(neighbors.size(), boost::degree(v, g));
		}
	}
}

/**
 * Ensure that graphs generated by gen_random_chordal_graph() are connected.
 */
BOOST_AUTO_TEST_CASE(random_chordal_graph_is_connected) {
	REPEAT(100) {
		Graph g = gen_random_chordal_graph<Graph>(100, 500);

		std::unordered_map<Vertex, VertexSz> component(boost::num_vertices(g));
		auto map = boost::make_assoc_property_map(component);
		auto n_components = boost::connected_components(g, map);

		BOOST_CHECK_EQUAL(n_components, 1);
	}
}

/**
 * Ensure that graphs generated by gen_random_chordal_graph() are actually
 * chordal.
 */
BOOST_AUTO_TEST_CASE(random_chordal_graph_is_chordal) {
	REPEAT(10) {
		Graph g = gen_random_chordal_graph<Graph>(7, 30);
		auto ordered = std::make_from_tuple<std::vector<Vertex>>(boost::vertices(g));

		do {
			for (const auto v : ordered) {
				for (const auto a : iter_neighbors(g, v)) {
					for (const auto b : iter_neighbors(g, v)) {
						if (a != b && !boost::edge(a, b, g).second)
							BOOST_FAIL("non-empty fill-in");
					}
				}
			}
		} while (boost::range::next_permutation(ordered)); // 7! = 5040
	}
}

/**
 * Ensure that the order of vertices generated by gen_random_order() is a
 * bijection vertex<->index with index in [0, n_vertices - 1].
 */
BOOST_AUTO_TEST_CASE(random_vertex_order_is_bijection) {
	Graph g;

	for (unsigned i = 0; i < 100000; i++)
		boost::add_vertex(g);

	auto order = gen_random_order(g);
	std::unordered_set<Vertex> vertices(boost::num_vertices(g));
	std::unordered_set<VertexSz> indices(boost::num_vertices(g));

	for (size_t i = 0; i < order.size(); i++) {
		indices.insert(i);
		vertices.insert(order[i]);
	}

	BOOST_CHECK_EQUAL(vertices.size(), boost::num_vertices(g));
	BOOST_CHECK_EQUAL(indices.size(), boost::num_vertices(g));
}

BOOST_AUTO_TEST_SUITE_END()
