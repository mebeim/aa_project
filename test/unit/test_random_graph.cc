/**
 * Unit tests for random-graph generation utilities that are used for actual
 * testing.
 */

#include <vector>
#include <tuple>
#include <unordered_set>
#include <boost/graph/connected_components.hpp>
#include <boost/graph/adjacency_list.hpp>
#include <boost/range/algorithm.hpp>
#include <boost/test/unit_test.hpp>

#include "utils.h"
#include "random_graph.h"

#define REPEAT(n) for (unsigned i__ = 0; i__ < (n); i__++)

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS> Graph;
typedef VertexDesc<Graph> Vertex;
typedef VertexSizeT<Graph> VertexSz;

BOOST_AUTO_TEST_SUITE(RandomGraphGeneration)

/**
 * Ensure that graphs generated by gen_random_connected_graph() are simple i.e.
 * they don't have multiple parallel edges between any pair of vertices.
 */
BOOST_AUTO_TEST_CASE(random_connected_graph_is_simple) {
	REPEAT(10) {
		Graph g = gen_random_connected_graph<Graph>(100, 1);

		for (auto v : iter_vertices(g)) {
			auto neighbors = std::make_from_tuple<std::unordered_set<Vertex>>(boost::adjacent_vertices(v, g));
			BOOST_CHECK_EQUAL(neighbors.size(), boost::degree(v, g));
		}
	}
}

/**
 * Ensure that graphs generated by gen_random_connected_graph() are actually
 * connected.
 */
BOOST_AUTO_TEST_CASE(random_connected_graph_is_connected) {
	REPEAT(100) {
		Graph g = gen_random_connected_graph<Graph>(100, 0);

		std::unordered_map<Vertex, VertexSz> component(boost::num_vertices(g));
		auto map = boost::make_assoc_property_map(component);
		auto n_components = boost::connected_components(g, map);

		BOOST_CHECK_EQUAL(n_components, 1);
	}
}

/**
 * Ensure that graphs generated by gen_random_connected_graph() are a single
 * chain of nodes when the given edge probability is 0. This assumes that the
 * graph is connected (which is checked by the above test).
 */
BOOST_AUTO_TEST_CASE(random_connected_graph_can_be_single_chain) {
	REPEAT(10) {
		Graph g = gen_random_connected_graph<Graph>(500, 0);
		VertexSz degree_two = 0;
		VertexSz degree_one = 0;

		for (const auto v : iter_vertices(g)) {
			const auto deg = boost::degree(v, g);

			if (deg == 2)
				degree_two++;
			else if (deg == 1)
				degree_one++;
		}

		BOOST_CHECK_EQUAL(degree_one, 2);
		BOOST_CHECK_EQUAL(degree_two, boost::num_vertices(g) - 2);
	}
}

/**
 * Ensure that graphs generated by gen_random_connected_graph() are complete
 * when the given edge probability is 1.
 */
BOOST_AUTO_TEST_CASE(random_connected_graph_can_be_complete) {
	REPEAT(10) {
		Graph g = gen_random_connected_graph<Graph>(500, 1);
		const auto n_vertices = boost::num_vertices(g);

		for (auto v : iter_vertices(g))
			BOOST_CHECK_EQUAL(boost::degree(v, g), n_vertices - 1);
	}
}

/**
 * Ensure that graphs generated by gen_random_chordal_graph() are simple i.e.
 * they don't have multiple parallel edges between any pair of vertices.
 */
BOOST_AUTO_TEST_CASE(random_chordal_graph_is_simple) {
	REPEAT(10) {
		Graph g = gen_random_chordal_graph<Graph>(100, 3000);

		for (auto v : iter_vertices(g)) {
			auto neighbors = std::make_from_tuple<std::unordered_set<Vertex>>(boost::adjacent_vertices(v, g));
			BOOST_CHECK_EQUAL(neighbors.size(), boost::degree(v, g));
		}
	}
}

/**
 * Ensure that graphs generated by gen_random_chordal_graph() are connected.
 */
BOOST_AUTO_TEST_CASE(random_chordal_graph_is_connected) {
	REPEAT(100) {
		Graph g = gen_random_chordal_graph<Graph>(100, 3000);

		std::unordered_map<Vertex, VertexSz> component(boost::num_vertices(g));
		auto map = boost::make_assoc_property_map(component);
		auto n_components = boost::connected_components(g, map);

		BOOST_CHECK_EQUAL(n_components, 1);
	}
}

/**
 * Ensure that graphs generated by gen_random_chordal_graph() are actually
 * chordal.
 */
BOOST_AUTO_TEST_CASE(random_chordal_graph_is_chordal) {
	REPEAT(10) {
		Graph g = gen_random_chordal_graph<Graph>(7, 25);
		auto ordered = std::make_from_tuple<std::vector<Vertex>>(boost::vertices(g));

		do {
			for (const auto v : ordered) {
				for (const auto a : iter_neighbors(g, v)) {
					for (const auto b : iter_neighbors(g, v)) {
						BOOST_CHECK_MESSAGE(
							a == b || boost::edge(a, b, g).second,
							"non-empty fill-in => graph is not cordal"
						);
					}
				}
			}
		} while (boost::range::next_permutation(ordered)); // 7! = 5040
	}
}

/**
 * Ensure that the order of vertices generated by gen_random_order() is a
 * bijection vertex<->index with index in [0, n_vertices - 1].
 */
BOOST_AUTO_TEST_CASE(random_vertex_order_is_bijection) {
	Graph g;

	for (unsigned i = 0; i < 100000; i++)
		boost::add_vertex(g);

	auto order = gen_random_order(g);
	std::unordered_set<Vertex> vertices(boost::num_vertices(g));
	std::unordered_set<VertexSz> indices(boost::num_vertices(g));

	for (size_t i = 0; i < order.size(); i++) {
		indices.insert(i);
		vertices.insert(order[i]);
	}

	BOOST_CHECK_EQUAL(vertices.size(), boost::num_vertices(g));
	BOOST_CHECK_EQUAL(indices.size(), boost::num_vertices(g));
}

BOOST_AUTO_TEST_SUITE_END()
